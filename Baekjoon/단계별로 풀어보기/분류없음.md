## 그리디 알고리즘

### [5585번 거스름돈](https://www.acmicpc.net/problem/5585)

OI잡화점에는 잔돈으로 500엔, 100엔, 50엔, 10엔, 5엔, 1엔이 충분히 있고, 언제나 거스름돈 개수가 가장 적게 잔돈을 준다.  
타로가 JOI잡화점에서 물건을 사고 카운터에서 1000엔 지폐를 한장 냈을 때,  
받을 잔돈에 포함된 잔돈의 개수를 구하는 프로그램을 작성하시오.

```python
import sys

n = int(sys.stdin.readline())
money = 1000 - n
coins = [500, 100, 50, 10, 5, 1]

cnt = 0
for coin in coins:
    cnt += money // coin
    money %= coin

    if money == 0:
        break

print(cnt)
```

---

### [2720번 세탁소 사장 동혁](https://www.acmicpc.net/problem/2720)

거스름돈의 액수가 주어지면 리암이 줘야할 쿼터(Quarter, $0.25)의 개수, 다임(Dime, $0.10)의 개수, 니켈(Nickel, $0.05)의 개수, 페니(Penny, $0.01)의 개수를 구하는 프로그램을 작성하시오.  
거스름돈은 항상 $5.00 이하이고, 손님이 받는 동전의 개수를 최소로 하려고 한다.  
예를 들어, $1.24를 거슬러 주어야 한다면, 손님은 4쿼터, 2다임, 0니켈, 4페니를 받게 된다.

```python
import sys

n = int(sys.stdin.readline())
coins = [25, 10, 5, 1]

for _ in range(n):
    c = int(sys.stdin.readline())
    for coin in coins:
        cnt = 0
        cnt += c // coin
        c %= coin
        print(cnt, end=' ')
    print()
```

---

### [2864번 5와 6의 차이](https://www.acmicpc.net/problem/2864)

상근이가 숫자 5를 볼 때, 5로 볼 때도 있지만, 6으로 잘못 볼 수도 있고,  
6을 볼 때는, 6으로 볼 때도 있지만, 5로 잘못 볼 수도 있다.

두 수 A와 B가 주어졌을 때, 상근이는 이 두 수를 더하려고 한다.  
이때, 상근이가 구할 수 있는 두 수의 가능한 합 중,  
최솟값과 최댓값을 구해 출력하는 프로그램을 작성하시오.

```python
import sys

a, b = map(str, sys.stdin.readline().rstrip().split())
min = int(a.replace('6', '5')) + int(b.replace('6', '5'))
max = int(a.replace('5', '6')) + int(b.replace('5', '6'))

print(min, max)
```

---

### [14659번 한조서열정리하고옴ㅋㅋ](https://www.acmicpc.net/problem/14659)

금강 산맥에는 총 N개의 봉우리가 있고, 모든 봉우리마다 한 명의 활잡이가 서서 월식이 시작되기만을 기다리고 있다.  
다만, 애석하게도, 천계에 맥도날드가 생겨 용들이 살이 찐 탓에 용들은 자신보다 낮은 봉우리에 서있는 적들만 처치할 수 있게 되었다.  
또한 용들은 처음 출발한 봉우리보다 높은 봉우리를 만나면 그대로 공격을 포기하고 금강산자락에 드러누워 낮잠을 청한다고 한다.  
봉우리의 높이는 모두 다르고 모든 용들은 오른쪽으로만 나아가며,  
중간에 방향을 틀거나, 봉우리가 무너지거나 솟아나는 경우는 없다.

첫째 줄에 봉우리의 수 겸 활잡이의 수 N이 주어진다. (1 ≤ N ≤ 30,000)  
둘째 줄에 N개 봉우리의 높이가 왼쪽 봉우리부터 순서대로 주어진다. (1 ≤ 높이 ≤ 100,000)  
각각 봉우리의 높이는 중복 없이 유일하다.

최고의 활잡이가 처치할 수 있는 적의 최대 숫자를 출력한다.

```text
더 큰 수를 만나기 전까지 카운트 세기
마지막에 cnt.append(c)를 적은 이유는 처음이 가장 클 봉우리인 경우 cnt에 값이 저장되지 않아 오류가 나온다
```

```python
import sys

n = int(sys.stdin.readline())
archer = list(map(int, sys.stdin.readline().split()))
cnt = []
a = archer[0]
c = 0
for i in range(1, n):
    if a > archer[i]:
        c += 1
    else:
        cnt.append(c)
        c = 0
        a = archer[i]
cnt.append(c)
print(max(cnt))
```

---

### [10162번 전자레인지](https://www.acmicpc.net/problem/10162)

```text
10으로 나누어 떨어지지 않으면 -1
```

```python
import sys

t = int(sys.stdin.readline())
button = [300, 60, 10]
push = []

if t % 10 != 0:
    print(-1)

else:
    for i in range(3):
        cnt = 0
        cnt += t // button[i]
        t %= button[i]
        push.append(cnt)

    for p in push:
        print(p, end=' ')
```

---

### [22864번 피로도](https://www.acmicpc.net/problem/22864)

하루에 한 시간 단위로 일을 하거나 일을 쉬어도 된다.  
하루에 한 시간 일하면 피로도는 A 만큼 쌓이고 일은 B 만큼 처리할 수 있다.

만약에 한 시간을 쉰다면 피로도는 C 만큼 줄어든다.  
단, 피로도가 음수로 내려가면 0으로 바뀐다.  
당연히 일을 하지 않고 쉬었기 때문에 처리한 일은 없다.

피로도를 최대한 M 을 넘지 않게 일을 하려고 한다.  
M 을 넘기면 일하는데 번아웃이 와서 이미 했던 일들도 다 던져버리고 일을 그만두게 된다.

번아웃이 되지 않도록 일을 할때 하루에 최대 얼마나 일을 할 수 있는지 구해보자. 하루는 24시간이다.

```python
a, b, c, m = map(int, input().split())

piro = 0
work = 0
for _ in range(24):
    if piro + a > m:
        piro -= c
        if piro < 0:
            piro = 0
    else:
        piro += a
        work += b

print(work)
```

---

### [15881번 Pen Pineapple Apple Pen](https://www.acmicpc.net/problem/15881)

여러 개의 사과, 파인애플, 그리고 펜이 일렬로 세워져 있다.  
이 물건들의 순서를 바꾸지 않고 옆에 있는 물건끼리 연결했을 때,  
펜-파인애플-애플-펜을 몇 개나 만들 수 있을지 세어보자.

단, 펜, 파인애플, 사과, 펜 순서로 연결된 네 개의 물건만을 펜-파인애플-애플-펜으로 인정하며,  
하나의 펜이 두 개의 펜-파인애플-애플-펜에 포함될 수 없다.  
또한 펜, 사과, 파인애플, 펜 순서로 연결된 네 개의 물건은 펜-파인애플-애플-펜이 아니다.

```text
pPAp를 0으로 모두 바꾼 뒤, 0의 갯수를 센다
```

```python
n = int(input())
ppap = input()

ppap = ppap.replace('pPAp', '0')

print(ppap.count('0'))
```

## DFS / BFS

### [1926번 그림](https://www.acmicpc.net/problem/1926)

어떤 큰 도화지에 그림이 그려져 있을 때,  
그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라.  
단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자.  
가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다.  
그림의 넓이란 그림에 포함된 1의 개수이다.

```text
2667번 단지번호붙이기와 비슷한 문제
DFS는 TypeError가 나와서 다시 풀어봐야 한다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    global art
    q = deque()
    q.append((x, y))
    art += 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < m:
                if graph[nx][ny] == 1:
                    graph[nx][ny] = 0
                    art += 1
                    q.append((nx, ny))
    return art

n, m = map(int, input().split())
arts = []
art = 0
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            graph[i][j] = 0
            arts.append(bfs(i, j))
        art = 0

if arts == []:
    print(0)
    print(0)
else:
    print(len(arts))
    print(max(arts))
```

---

### [2468번 안전 영역](https://www.acmicpc.net/problem/2468)

장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다.  
위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면  
물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.

어떤 지역의 높이 정보가 주어졌을 때,  
장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.

```text
방문 장소를 초기화해주면서 제일 낮은 높이부터 제일 높은 높이까지 반복문을 돌려 어느 높이가 가장 많은 안전 영역을 갖는지 구해준다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def bfs(x, y, k):
    visited[x][y] = 1
    q = deque()
    q.append((x, y))

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < n:
                if graph[nx][ny] > k and visited[nx][ny] == 0:
                    visited[nx][ny] = 1
                    q.append((nx, ny))

n = int(input())
graph = []
land = 0
max_land = 0
for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(n):
        if graph[i][j] > max_land:
            max_land = graph[i][j]


for k in range(max_land):
    tmp = 0
    visited = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if graph[i][j] > k and visited[i][j] == 0:
                visited[i][j] = 1
                tmp += 1
                bfs(i, j, k)
    land = max(land, tmp)
print(land)
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def dfs(x, y, k):
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n:
            if graph[nx][ny] > k and visited[nx][ny] == 0:
                visited[nx][ny] = 1
                dfs(nx, ny, k)


n = int(input())
graph = []
land = 0
max_land = 0
for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(n):
        if graph[i][j] > max_land:
            max_land = graph[i][j]


for k in range(max_land):
    tmp = 0
    visited = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if graph[i][j] > k and visited[i][j] == 0:
                visited[i][j] = 1
                tmp += 1
                dfs(i, j, k)
    land = max(land, tmp)
print(land)
```

### [4963번 섬의 개수](https://www.acmicpc.net/problem/4963)

정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.

한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다.

두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다.  
지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.

```text
다른 문제들과 비슷했지만 다른 점은 8방향으로 이동할 수 있다는 점
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, -1, 1, 1, -1]

def dfs(x, y):
    if graph[x][y] == 1:
        graph[x][y] = 0
        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                continue
            dfs(nx, ny)

while True:
    w, h = map(int, input().split())
    cnt = 0

    if w == h == 0:
        break

    graph = []
    for _ in range(h):
        graph.append(list(map(int, input().split())))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == 1:
                dfs(i, j)
                cnt += 1
    print(cnt)
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, -1, 1, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    graph[x][y] = 0

    while q:
        x, y = q.popleft()

        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                continue

            if graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))

while True:
    w, h = map(int, input().split())
    cnt = 0

    if w == h == 0:
        break

    graph = []
    for _ in range(h):
        graph.append(list(map(int, input().split())))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == 1:
                bfs(i, j)
                cnt += 1
    print(cnt)
```

---

### [16953번 A → B](https://www.acmicpc.net/problem/16953)

정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

1. 2를 곱한다.
2. 1을 수의 가장 오른쪽에 추가한다.

A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

```text
이 문제를 보고 처음엔 DP 문제가 아닌가 생각했는데 일단 분류가 BFS로 되어 있어 BFS로 풀어보았다
count 처리를 어떻게 해야 할까 고민했는데 튜플로 n값과 cnt값을 동시에 넣어주니 해결되었다
나중에 찾아보니 top-down 방식으로도 풀 수 있는 문제여서 b를 a로 만들어주면 된다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

def bfs(n, m):
    q = deque()
    q.append((n, 1))

    while q:
        n, cnt = q.popleft()

        if n == m:
            return cnt
        elif n > b:
            continue

        q.append((2 * n, cnt + 1))
        q.append((int(str(n) + '1'), cnt + 1))
    return -1

a, b = map(int, input().split())
print(bfs(a, b))
```

```python
# top-down
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
cnt = 1

while True:
    if b == a:
        break
    elif b < a:
        cnt = -1
        break

    if b % 10 == 1:
        b //= 10
        cnt += 1
    elif b % 2 == 0:
        b //= 2
        cnt += 1
    else:
        cnt = -1
        break

print(cnt)
```

---

### [1743번 음식물 피하기](https://www.acmicpc.net/problem/1743)

코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다.  
그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다.  
이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다.

통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다.  
따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다.

선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra"를 외치지 않게 도와주자.

```text
다른 문제들과 비슷한 문제인데 이상하게 풀리지 않은 문제
```

```python
import sys
sys.setrecursionlimit(10 ** 8)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    global cnt

    visited[x][y] = True
    if graph[x][y] == 1:
         cnt += 1

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] == 1 and not visited[nx][ny]:
                dfs(nx, ny)

n, m, k = map(int, input().split())
graph = [[0] * m for _ in range(n)]
visited = [[False] * m for _ in range(n)]
result = 0

# 그래프 구현
for i in range(k):
    u, v = map(int, input().split())
    graph[u-1][v-1] = 1

# 그래프 탐색
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1 and not visited[i][j]:
            cnt = 0
            dfs(i, j)
            result = max(result, cnt)

print(result)
```

---

### [1303번 전쟁 - 전투](https://www.acmicpc.net/problem/1303)

전쟁은 어느덧 전면전이 시작되었다.  
결국 전투는 난전이 되었고, 우리 병사와 적국 병사가 섞여 싸우게 되었다.  
그러나 당신의 병사들은 흰색 옷을 입고, 적국의 병사들은 파란색 옷을 입었기 때문에 서로가 적인지 아군인지는 구분할 수 있다.  
문제는 같은 팀의 병사들은 모이면 모일수록 강해진다는 사실이다.

N명이 뭉쳐있을 때는 N2의 위력을 낼 수 있다.  
과연 지금 난전의 상황에서는 누가 승리할 것인가?  
단, 같은 팀의 병사들이 대각선으로만 인접한 경우는 뭉쳐 있다고 보지 않는다.

```text
틀렸던 이유는 가로 크기가 N, 세로 크기가 M인걸 보지 못하고 가로 크기를 M, 세로 크기를 N으로 놓고 풀었기 때문

처음엔 visited를 두 번 초기화하여 bfs를 두 번 돌려야 하나 고민했었는데 생각해보니 방문처리를 graph에서 다른 값으로 하는게 아닌 visited를 이용하는 것이므로 한 번의 이중 for문에서 해결하였음
```

```python
import sys
from collections import deque
input = sys.stdin.readline

def bfs(x, y, team):
    global cnt
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < m and 0 <= ny < n:
                if graph[nx][ny] == team and visited[nx][ny] == False:
                    visited[nx][ny] = True
                    cnt += 1
                    q.append((nx, ny))

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]
n, m = map(int, input().split())
graph = []
cnt_w = 0
cnt_b = 0

# 그래프 구현
for _ in range(m):
    graph.append(list(input().rstrip()))

visited = [[False] * n for _ in range(m)]

# 그래프 탐색
for i in range(m):
    for j in range(n):
        cnt = 1
        # 흰색 팀일 경우
        if graph[i][j] == 'W' and visited[i][j] == False:
            bfs(i, j, 'W')
            if cnt > 1:
                cnt_w += cnt ** 2
            else:
                cnt_w += cnt
        # 파란 팀일 경우
        elif graph[i][j] == 'B' and visited[i][j] == False:
            bfs(i, j, 'B')
            if cnt > 1:
                cnt_b += cnt ** 2
            else:
                cnt_b += cnt

print(cnt_w, cnt_b)
```

---

### [11123번 양 한마리... 양 두마리...](https://www.acmicpc.net/problem/11123)

양을 # 으로 나타내고 . 으로 풀을 표현하는 거야. 서로 다른 # 두 개 이상이 붙어있다면 한 무리의 양들이 있는거지.  
그래... 좋았어..! 이걸로 초원에서 풀을 뜯고 있는 양들을 그리드로 표현해 보는거야!

각 테스트 케이스마다, 양의 몇 개의 무리로 이루어져 있었는지를 한 줄에 출력하면 된다.

```text
다른 문제와 같은 구역 세는 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

case = int(input())

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < h and 0 <= ny < w:
                if graph[nx][ny] == '#' and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny))




for _ in range(case):
    h, w = map(int, input().split())
    graph = []
    visited = [[False] * w for __ in range(h)]
    cnt = 0

    for __ in range(h):
        graph.append(list(input().rstrip()))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == '#' and not visited[i][j]:
                cnt += 1
                bfs(i, j)

    print(cnt)
```

---

### [1937번 욕심쟁이 판다](https://www.acmicpc.net/problem/1937)

n × n의 크기의 대나무 숲이 있다.  
욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다.  
그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다.  
그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다.  
이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다.

이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데,  
어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 판다가 최대한 많은 칸을 방문할 수 있는지 고민에 빠져 있다.  
우리의 임무는 이 사육사를 도와주는 것이다.

n × n 크기의 대나무 숲이 주어져 있을 때,  
이 판다가 최대한 많은 칸을 이동하려면 어떤 경로를 통하여 움직여야 하는지 구하여라.

```text
DFS + DP 문제
처음엔 DFS로 구현하다가 BFS로 하면 쉬울 것 같아 BFS로 구현을 했는데 풀리지 않았다

각 점마다 모두 탐색을 진행하는 줄 알았는데 그렇게 하면 시간초과가 나고 어떠한 좌표로 이동한 최장 경로의 길이는 다시 계산할 필요가 없으므로 DP가 사용된다

BFS는 최단 거리를 구하는 알고리즘이기 때문에 DFS를 써야 한다

그러므로 이 문제는 DFS와 DP를 이용해서 푸는 문제이다

DP를 그래프에서도 활용할 수 있다는 걸 깨달았다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    if dp[x][y]:
        return dp[x][y]

    dp[x][y] = 1

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n:
            if graph[x][y] < graph[nx][ny]:
                dp[x][y] = max(dp[x][y], dfs(nx, ny) + 1)
    return dp[x][y]

n = int(input())

graph = [list(map(int, input().split())) for _ in range(n)]
dp = [[0] * n for _ in range(n)]
result = 0

for i in range(n):
    for j in range(n):
        result = max(result, dfs(i, j))

print(result)
```

---

## DP

### [2193번 이친수](https://www.acmicpc.net/problem/2193)

0과 1로만 이루어진 수를 이진수라 한다.  
이러한 이진수 중 특별한 성질을 갖는 것들이 있는데, 이들을 이친수(pinary number)라 한다.  
이친수는 다음의 성질을 만족한다.

이친수는 0으로 시작하지 않는다.  
이친수에서는 1이 두 번 연속으로 나타나지 않는다. 즉, 11을 부분 문자열로 갖지 않는다.
예를 들면 1, 10, 100, 101, 1000, 1001 등이 이친수가 된다.  
하지만 0010101이나 101101은 각각 1, 2번 규칙에 위배되므로 이친수가 아니다.

```python
n = int(input())
dp = [0, 1, 1, 2]
for i in range(4, n + 1):
    dp.append(dp[i - 1] + dp[i - 2])
print(dp[n])
```

---

### [11057번 오르막 수](https://www.acmicpc.net/problem/11057)

오르막 수는 수의 자리가 오름차순을 이루는 수를 말한다. 이때, 인접한 수가 같아도 오름차순으로 친다.  
예를 들어, 2234와 3678, 11119는 오르막 수이지만, 2232, 3676, 91111은 오르막 수가 아니다.  
수의 길이 N이 주어졌을 때, 오르막 수의 개수를 구하는 프로그램을 작성하시오.  
수는 0으로 시작할 수 있다.

```text
10844번 쉬운 계단 수와 비슷한 문제
0을 선택할 경우 뒷 자리에 1~9가 올 수 있으므로 그만큼의 수를 더해주고
앞자리와 뒷자리를 비교해 사용할 수 있는 만큼 더해준다
```

```python
n = int(input())
m = 10007
dp = [[0] * 10 for _ in range(n + 1)]
for i in range(10):
    dp[1][i] = 1

for i in range(2, n + 1):
    for j in range(10):
        for k in range(j, 10):
            dp[i][j] += dp[i - 1][k]

print(sum(dp[n]) % m)
```
