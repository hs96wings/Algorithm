## 25 그래프와 순회

### [24479번 알고리즘 수업 - 깊이 우선 탐색 1](https://www.acmicpc.net/problem/24479)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.

```text
재귀 문제를 풀 때는 꼭 sys.setrecursionlimit(10 ** 6)를 써주어야 한다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)

def dfs(start):
    global cnt
    visited[start] = cnt
    graph[start].sort()

    for i in graph[start]:
        if not visited[i]:
            cnt += 1
            dfs(i)

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

dfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24480번 알고리즘 수업 - 깊이 우선 탐색 2](https://www.acmicpc.net/problem/24480)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```text
24479번에서 바뀐건 내림차순뿐이기에 sort()에서 sort(reverse=True)로 바꿔준다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)

def dfs(start):
    global cnt
    visited[start] = cnt
    graph[start].sort(reverse=True)

    for i in graph[start]:
        if not visited[i]:
            cnt += 1
            dfs(i)

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    x, y = map(int, sys.stdin.readline().rstrip().split())
    graph[x].append(y)
    graph[y].append(x)

dfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24444번 알고리즘 수업 - 너비 우선 탐색 1](https://www.acmicpc.net/problem/24444)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.

```python
import sys
from collections import deque

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort()

bfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24445번 알고리즘 수업 - 너비 우선 탐색 2](https://www.acmicpc.net/problem/24445)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```text
24444번에서 바뀐건 dfs 문제와 같이 내림차순뿐이기에 sort()에서 sort(reverse=True)로 바꿔준다
```

```python
import sys
from collections import deque

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort(reverse=True)

bfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [2606번 바이러스](https://www.acmicpc.net/problem/2606)

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다.  
컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때,  
1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

```text
1번부터 시작이면 연결되어 있지 않은 정점은 탐색을 진행하지 않을테니
DFS나 BFS를 써서 순서를 구한 후 마지막으로 방문한 노드번째에서 첫번째 노드를 빼준다
```

```python
import sys
from collections import deque

input = sys.stdin.readline

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n = int(input())
m = int(input())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

bfs(1)

print(max(visited) - 1)
```

---

### [1260번 DFS와 BFS](https://www.acmicpc.net/problem/1260)

그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오.  
단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다.  
정점 번호는 1번부터 N번까지이다.

```python
import sys
from collections import deque
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

def bfs(start):
    queue = deque([start])

    visited[start] = True

    while queue:
        v = queue.popleft()
        print(v, end=' ')

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

def dfs(start):
    visited[start] = True
    print(start, end=' ')
    for i in graph[start]:
        if not visited[i]:
            dfs(i)

n, m, r = map(int, input().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)

for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort()

dfs(r)
print()

visited = [0] * (n + 1)

bfs(r)
```

---

### [2178번 미로 탐색](https://www.acmicpc.net/problem/2178)

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다.  
이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오.  
한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

```python
import sys
from collections import deque

input = sys.stdin.readline

def bfs(x, y):
    queue = deque()
    queue.append((x, y))

    while queue:
        x, y = queue.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            if graph[nx][ny] == 0:
                continue
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx, ny))

    return graph[n - 1][m - 1]

n, m = map(int, input().rstrip().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input().rstrip())))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

print(bfs(0, 0))
```
