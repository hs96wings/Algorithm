## 25 그래프와 순회

### [24479번 알고리즘 수업 - 깊이 우선 탐색 1](https://www.acmicpc.net/problem/24479)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.

```text
재귀 문제를 풀 때는 꼭 sys.setrecursionlimit(10 ** 6)를 써주어야 한다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)

def dfs(start):
    global cnt
    visited[start] = cnt
    graph[start].sort()

    for i in graph[start]:
        if not visited[i]:
            cnt += 1
            dfs(i)

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

dfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24480번 알고리즘 수업 - 깊이 우선 탐색 2](https://www.acmicpc.net/problem/24480)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```text
24479번에서 바뀐건 내림차순뿐이기에 sort()에서 sort(reverse=True)로 바꿔준다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)

def dfs(start):
    global cnt
    visited[start] = cnt
    graph[start].sort(reverse=True)

    for i in graph[start]:
        if not visited[i]:
            cnt += 1
            dfs(i)

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    x, y = map(int, sys.stdin.readline().rstrip().split())
    graph[x].append(y)
    graph[y].append(x)

dfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24444번 알고리즘 수업 - 너비 우선 탐색 1](https://www.acmicpc.net/problem/24444)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.

```python
import sys
from collections import deque

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort()

bfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [24445번 알고리즘 수업 - 너비 우선 탐색 2](https://www.acmicpc.net/problem/24445)

N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다.  
정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다.  
정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.

너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.

```text
24444번에서 바뀐건 dfs 문제와 같이 내림차순뿐이기에 sort()에서 sort(reverse=True)로 바꿔준다
```

```python
import sys
from collections import deque

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n, m, r = map(int, sys.stdin.readline().rstrip().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, sys.stdin.readline().rstrip().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort(reverse=True)

bfs(r)

for i in range(1, n + 1):
    print(visited[i])
```

---

### [2606번 바이러스](https://www.acmicpc.net/problem/2606)

어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다.  
컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때,  
1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.

```text
1번부터 시작이면 연결되어 있지 않은 정점은 탐색을 진행하지 않을테니
DFS나 BFS를 써서 순서를 구한 후 마지막으로 방문한 노드번째에서 첫번째 노드를 빼준다
```

```python
import sys
from collections import deque

input = sys.stdin.readline

def bfs(start):
    global cnt
    queue = deque([start])
    visited[start] = cnt

    while queue:
        v = queue.popleft()

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                cnt += 1
                visited[i] = cnt

n = int(input())
m = int(input())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)
cnt = 1

for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

bfs(1)

print(max(visited) - 1)
```

---

### [1260번 DFS와 BFS](https://www.acmicpc.net/problem/1260)

그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오.  
단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다.  
정점 번호는 1번부터 N번까지이다.

```python
import sys
from collections import deque
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

def bfs(start):
    queue = deque([start])

    visited[start] = True

    while queue:
        v = queue.popleft()
        print(v, end=' ')

        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

def dfs(start):
    visited[start] = True
    print(start, end=' ')
    for i in graph[start]:
        if not visited[i]:
            dfs(i)

n, m, r = map(int, input().split())
graph = [[] for _ in range(n + 1)]
visited = [0] * (n + 1)

for _ in range(m):
    u, v = map(int, input().split())
    graph[u].append(v)
    graph[v].append(u)

for i in range(n + 1):
    graph[i].sort()

dfs(r)
print()

visited = [0] * (n + 1)

bfs(r)
```

---

### [2667번 단지번호붙이기](https://www.acmicpc.net/problem/2667)

<그림 1>과 같이 정사각형 모양의 지도가 있다.  
1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다.  
철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다.  
여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다.  
대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다.  
지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.

첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.

```text
DFS를 이용하여 풀었다
단지 하나를 재귀로 돌면서 방 수를 확인했다
6%에서 틀렸던 이유는 단지내 집의 수를 오름차순으로 정렬하지 않았기 때문에 틀렸었다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    n = len(graph)
    q = deque()
    q.append((x, y))
    graph[x][y] = 0
    cnt = 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= n or ny < 0 or ny >= n:
                continue

            # 방문하지 않았다면 0으로 만들어 방문처리
            if graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))
                cnt += 1
    return cnt

n = int(input())

graph = []
for i in range(n):
    graph.append(list(map(int, input().rstrip())))

rooms = []
for i in range(n):
    for j in range(n):
        if graph[i][j] == 1:
            rooms.append(bfs(i, j))

print(len(rooms))
rooms.sort()
for i in range(len(rooms)):
    print(rooms[i])
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    global room
    if x <= -1 or x >= n or y <= -1 or y >= n:
        return False

    if graph[x][y] == 1:
        graph[x][y] = 0
        room += 1
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            dfs(nx, ny)
        return True
    return False

n = int(input().rstrip())

graph = []
for i in range(n):
    graph.append(list(map(int, input().rstrip())))

rooms = []
room = 0
for i in range(n):
    for j in range(n):
        if dfs(i, j) == True:
            rooms.append(room)
            room = 0

print(len(rooms))
rooms.sort()
for i in range(len(rooms)):
    print(rooms[i])
```

---

### [1012번 유기농 배추](https://www.acmicpc.net/problem/1012)

한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다.  
배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로  
서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다.  
예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다.  
0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.

```text
배추들의 묶음이 몇 묶음인지 알아내면 되는 문제이므로 bfs나 dfs를 사용해 배추 묶음을 찾는다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    graph[x][y] = 0

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue

            # 만약 배추라면 0으로 만들어 방문처리
            if graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))

case = int(input())

for _ in range(case):
    n, m, k = map(int, input().split())
    graph = [[0] * m for __ in range(n)]
    cnt = 0

    for __ in range(k):
        x, y = map(int, input().split())
        graph[x][y] = 1


    for i in range(n):
        for j in range(m):
            if graph[i][j] == 1:
                cnt += 1
                bfs(i, j)

    print(cnt)
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    if graph[x][y] == 1:
        graph[x][y] = 0
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            dfs(nx, ny)

case = int(input())

for _ in range(case):
    n, m, k = map(int, input().split())
    graph = [[0] * m for __ in range(n)]
    cnt = 0

    for __ in range(k):
        x, y = map(int, input().split())
        graph[x][y] = 1


    for i in range(n):
        for j in range(m):
            if graph[i][j] == 1:
                cnt += 1
                dfs(i, j)

    print(cnt)
```

---

### [2178번 미로 탐색](https://www.acmicpc.net/problem/2178)

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다.  
이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오.  
한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

```python
import sys
from collections import deque

input = sys.stdin.readline

def bfs(x, y):
    queue = deque()
    queue.append((x, y))

    while queue:
        x, y = queue.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= n or ny < 0 or ny >= m:
                continue
            if graph[nx][ny] == 0:
                continue
            if graph[nx][ny] == 1:
                graph[nx][ny] = graph[x][y] + 1
                queue.append((nx, ny))

    return graph[n - 1][m - 1]

n, m = map(int, input().rstrip().split())
graph = []
for i in range(n):
    graph.append(list(map(int, input().rstrip())))

dx = [-1, 1, 0, 0]
dy = [0, 0, -1, 1]

print(bfs(0, 0))
```
