## 20 큐, 덱

### [18258번 큐 2](https://www.acmicpc.net/problem/18258)

push X: 정수 X를 큐에 넣는 연산이다.  
pop: 큐에서 가장 앞에 있는 정수를 빼고, 그 수를 출력한다.  
만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.  
size: 큐에 들어있는 정수의 개수를 출력한다.  
empty: 큐가 비어있으면 1, 아니면 0을 출력한다.  
front: 큐의 가장 앞에 있는 정수를 출력한다.  
만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.  
back: 큐의 가장 뒤에 있는 정수를 출력한다.  
만약 큐에 들어있는 정수가 없는 경우에는 -1을 출력한다.

```cpp
#include <iostream>
#include <queue>
#include <string>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cout.tie(NULL);
    cin.tie(NULL);
    int n, t;
    queue<int> q;
    string str;

    cin >> n;

    for (int i = 0; i < n; ++i) {
        cin >> str;

        if (str == "push") {
            cin >> t;
            q.push(t);
        } else if (str == "pop") {
            if (!q.empty()) {
                cout << q.front() << '\n';
                q.pop();
            } else {
                cout << -1 << '\n';
            }
        } else if (str == "size") {
            cout << q.size() << '\n';
        } else if (str == "empty") {
            if (!q.empty()) {
                cout << 0 << '\n';
            } else {
                cout << 1 << '\n';
            }
        } else if (str == "front") {
            if (!q.empty()) {
                cout << q.front() << '\n';
            } else {
                cout << -1 << '\n';
            }
        } else if (str == "back") {
            if (!q.empty()) {
                cout << q.back() << '\n';
            } else {
                cout << -1 << '\n';
            }
        }
    }
    return 0;
}
```

```python
import sys
from collections import deque

n = int(sys.stdin.readline())
queue = deque()

for _ in range(n):
    op = sys.stdin.readline().split()

    if op[0] == 'push':
        queue.append(op[1])
    elif op[0] == 'pop':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue.popleft())
    elif op[0] == 'size':
        print(len(queue))
    elif op[0] == 'empty':
        if len(queue) == 0:
            print(1)
        else:
            print(0)
    elif op[0] == 'front':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue[0])
    elif op[0] == 'back':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue[-1])
```

---

### [2164번 카드2](https://www.acmicpc.net/problem/2164)

우선, 제일 위에 있는 카드를 바닥에 버린다.  
그 다음, 제일 위에 있는 카드를 제일 아래에 있는 카드 밑으로 옮긴다.  
이제 다음과 같은 동작을 카드가 한 장 남을 때까지 반복하게 된다.

N이 주어졌을 때, 제일 마지막에 남게 되는 카드를 구하는 프로그램을 작성하시오.

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    cin.tie(NULL);
    int n, t;
    queue<int> q;

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        q.push(i);
    }

    while (q.size() > 1) {
        q.pop();
        t = q.front();
        q.pop();
        q.push(t);
    }

    cout << q.front() << '\n';

    return 0;
}
```

```python
import sys
from collections import deque

n = int(sys.stdin.readline())

queue = deque([x for x in range(1, n+1)])

while len(queue) > 1:
    queue.popleft()
    k = queue.popleft()
    queue.append(k)

print(queue.popleft())
```

---

### [10866번 덱](https://www.acmicpc.net/problem/10866)

push_front X: 정수 X를 덱의 앞에 넣는다.  
push_back X: 정수 X를 덱의 뒤에 넣는다.  
pop_front: 덱의 가장 앞에 있는 수를 빼고, 그 수를 출력한다.  
만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.  
pop_back: 덱의 가장 뒤에 있는 수를 빼고, 그 수를 출력한다.  
만약, 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.  
size: 덱에 들어있는 정수의 개수를 출력한다.  
empty: 덱이 비어있으면 1을, 아니면 0을 출력한다.  
front: 덱의 가장 앞에 있는 정수를 출력한다.  
만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.  
back: 덱의 가장 뒤에 있는 정수를 출력한다.  
만약 덱에 들어있는 정수가 없는 경우에는 -1을 출력한다.

```cpp
#include <iostream>
#include <deque>
#include <string>
using namespace std;

int main() {
    cin.tie(NULL);
    int n, t;
    deque<int> d;
    string s;

    cin >> n;

    for (int i = 0; i < n; ++i) {
        cin >> s;

        if (s == "push_front") {
            cin >> t;
            d.push_front(t);
        } else if (s == "push_back") {
            cin >> t;
            d.push_back(t);
        } else if (s == "pop_front") {
            if (!d.empty()) {
                cout << d.front() << '\n';
                d.pop_front();
            } else {
                cout << -1 << '\n';
            }
        } else if (s == "pop_back") {
            if (!d.empty()) {
                cout << d.back() << '\n';
                d.pop_back();
            } else {
                cout << -1 << '\n';
            }
        } else if (s == "size") {
            cout << d.size() << '\n';
        } else if (s == "empty") {
            if (!d.empty()) {
                cout << 0 << '\n';
            } else {
                cout << 1 << '\n';
            }
        } else if (s == "front") {
            if (!d.empty()) {
                cout << d.front() << '\n';
            } else {
                cout << -1 << '\n';
            }
        } else if (s == "back") {
            if (!d.empty()) {
                cout << d.back() << '\n';
            } else {
                cout << -1 << '\n';
            }
        }
    }

    return 0;
}
```

```python
import sys
from collections import deque

n = int(sys.stdin.readline())
queue = deque()

for _ in range(n):
    op = sys.stdin.readline().split()

    if op[0] == 'push_front':
        queue.appendleft(int(op[1]))
    elif op[0] == 'push_back':
        queue.append(int(op[1]))
    elif op[0] == 'pop_front':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue.popleft())
    elif op[0] == 'pop_back':
        if (len(queue)) == 0:
            print(-1)
        else:
            print(queue.pop())
    elif op[0] == 'size':
        print(len(queue))
    elif op[0] == 'empty':
        if len(queue) == 0:
            print(1)
        else:
            print(0)
    elif op[0] == 'front':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue[0])
    elif op[0] == 'back':
        if len(queue) == 0:
            print(-1)
        else:
            print(queue[-1])
```
