## DFS / BFS

### [1926번 그림](https://www.acmicpc.net/problem/1926)

어떤 큰 도화지에 그림이 그려져 있을 때,  
그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라.  
단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자.  
가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다.  
그림의 넓이란 그림에 포함된 1의 개수이다.

```text
2667번 단지번호붙이기와 비슷한 문제
DFS는 TypeError가 나와서 다시 풀어봐야 한다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    global art
    q = deque()
    q.append((x, y))
    art += 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < m:
                if graph[nx][ny] == 1:
                    graph[nx][ny] = 0
                    art += 1
                    q.append((nx, ny))
    return art

n, m = map(int, input().split())
arts = []
art = 0
graph = []
for _ in range(n):
    graph.append(list(map(int, input().split())))

for i in range(n):
    for j in range(m):
        if graph[i][j] == 1:
            graph[i][j] = 0
            arts.append(bfs(i, j))
        art = 0

if arts == []:
    print(0)
    print(0)
else:
    print(len(arts))
    print(max(arts))
```

---

### [2468번 안전 영역](https://www.acmicpc.net/problem/2468)

장마철에 내리는 비의 양에 따라서 물에 잠기지 않는 안전한 영역의 개수는 다르게 된다.  
위의 예와 같은 지역에서 내리는 비의 양에 따른 모든 경우를 다 조사해 보면  
물에 잠기지 않는 안전한 영역의 개수 중에서 최대인 경우는 5임을 알 수 있다.

어떤 지역의 높이 정보가 주어졌을 때,  
장마철에 물에 잠기지 않는 안전한 영역의 최대 개수를 계산하는 프로그램을 작성하시오.

```text
방문 장소를 초기화해주면서 제일 낮은 높이부터 제일 높은 높이까지 반복문을 돌려 어느 높이가 가장 많은 안전 영역을 갖는지 구해준다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def bfs(x, y, k):
    visited[x][y] = 1
    q = deque()
    q.append((x, y))

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < n:
                if graph[nx][ny] > k and visited[nx][ny] == 0:
                    visited[nx][ny] = 1
                    q.append((nx, ny))

n = int(input())
graph = []
land = 0
max_land = 0
for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(n):
        if graph[i][j] > max_land:
            max_land = graph[i][j]


for k in range(max_land):
    tmp = 0
    visited = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if graph[i][j] > k and visited[i][j] == 0:
                visited[i][j] = 1
                tmp += 1
                bfs(i, j, k)
    land = max(land, tmp)
print(land)
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]


def dfs(x, y, k):
    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n:
            if graph[nx][ny] > k and visited[nx][ny] == 0:
                visited[nx][ny] = 1
                dfs(nx, ny, k)


n = int(input())
graph = []
land = 0
max_land = 0
for i in range(n):
    graph.append(list(map(int, input().split())))
    for j in range(n):
        if graph[i][j] > max_land:
            max_land = graph[i][j]


for k in range(max_land):
    tmp = 0
    visited = [[0] * n for _ in range(n)]

    for i in range(n):
        for j in range(n):
            if graph[i][j] > k and visited[i][j] == 0:
                visited[i][j] = 1
                tmp += 1
                dfs(i, j, k)
    land = max(land, tmp)
print(land)
```

---

### [4963번 섬의 개수](https://www.acmicpc.net/problem/4963)

정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.

한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다.

두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다.  
지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.

```text
다른 문제들과 비슷했지만 다른 점은 8방향으로 이동할 수 있다는 점
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, -1, 1, 1, -1]

def dfs(x, y):
    if graph[x][y] == 1:
        graph[x][y] = 0
        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]
            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                continue
            dfs(nx, ny)

while True:
    w, h = map(int, input().split())
    cnt = 0

    if w == h == 0:
        break

    graph = []
    for _ in range(h):
        graph.append(list(map(int, input().split())))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == 1:
                dfs(i, j)
                cnt += 1
    print(cnt)
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, -1, 1, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    graph[x][y] = 0

    while q:
        x, y = q.popleft()

        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]

            if nx < 0 or nx >= h or ny < 0 or ny >= w:
                continue

            if graph[nx][ny] == 1:
                graph[nx][ny] = 0
                q.append((nx, ny))

while True:
    w, h = map(int, input().split())
    cnt = 0

    if w == h == 0:
        break

    graph = []
    for _ in range(h):
        graph.append(list(map(int, input().split())))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == 1:
                bfs(i, j)
                cnt += 1
    print(cnt)
```

---

### [16953번 A → B](https://www.acmicpc.net/problem/16953)

정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.

1. 2를 곱한다.
2. 1을 수의 가장 오른쪽에 추가한다.

A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

```text
이 문제를 보고 처음엔 DP 문제가 아닌가 생각했는데 일단 분류가 BFS로 되어 있어 BFS로 풀어보았다
count 처리를 어떻게 해야 할까 고민했는데 튜플로 n값과 cnt값을 동시에 넣어주니 해결되었다
나중에 찾아보니 top-down 방식으로도 풀 수 있는 문제여서 b를 a로 만들어주면 된다
```

```python
# BFS
import sys
from collections import deque
input = sys.stdin.readline

def bfs(n, m):
    q = deque()
    q.append((n, 1))

    while q:
        n, cnt = q.popleft()

        if n == m:
            return cnt
        elif n > b:
            continue

        q.append((2 * n, cnt + 1))
        q.append((int(str(n) + '1'), cnt + 1))
    return -1

a, b = map(int, input().split())
print(bfs(a, b))
```

```python
# top-down
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
cnt = 1

while True:
    if b == a:
        break
    elif b < a:
        cnt = -1
        break

    if b % 10 == 1:
        b //= 10
        cnt += 1
    elif b % 2 == 0:
        b //= 2
        cnt += 1
    else:
        cnt = -1
        break

print(cnt)
```

---

### [1743번 음식물 피하기](https://www.acmicpc.net/problem/1743)

코레스코 콘도미니엄 8층은 학생들이 3끼의 식사를 해결하는 공간이다.  
그러나 몇몇 비양심적인 학생들의 만행으로 음식물이 통로 중간 중간에 떨어져 있다.  
이러한 음식물들은 근처에 있는 것끼리 뭉치게 돼서 큰 음식물 쓰레기가 된다.

통로에 떨어진 음식물을 피해가기란 쉬운 일이 아니다.  
따라서 선생님은 떨어진 음식물 중에 제일 큰 음식물만은 피해 가려고 한다.

선생님을 도와 제일 큰 음식물의 크기를 구해서 “10ra"를 외치지 않게 도와주자.

```text
다른 문제들과 비슷한 문제인데 이상하게 풀리지 않은 문제
```

```python
import sys
sys.setrecursionlimit(10 ** 8)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    global cnt

    visited[x][y] = True
    if graph[x][y] == 1:
         cnt += 1

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] == 1 and not visited[nx][ny]:
                dfs(nx, ny)

n, m, k = map(int, input().split())
graph = [[0] * m for _ in range(n)]
visited = [[False] * m for _ in range(n)]
result = 0

# 그래프 구현
for i in range(k):
    u, v = map(int, input().split())
    graph[u-1][v-1] = 1

# 그래프 탐색
for i in range(n):
    for j in range(m):
        if graph[i][j] == 1 and not visited[i][j]:
            cnt = 0
            dfs(i, j)
            result = max(result, cnt)

print(result)
```

---

### [1303번 전쟁 - 전투](https://www.acmicpc.net/problem/1303)

전쟁은 어느덧 전면전이 시작되었다.  
결국 전투는 난전이 되었고, 우리 병사와 적국 병사가 섞여 싸우게 되었다.  
그러나 당신의 병사들은 흰색 옷을 입고, 적국의 병사들은 파란색 옷을 입었기 때문에 서로가 적인지 아군인지는 구분할 수 있다.  
문제는 같은 팀의 병사들은 모이면 모일수록 강해진다는 사실이다.

N명이 뭉쳐있을 때는 N2의 위력을 낼 수 있다.  
과연 지금 난전의 상황에서는 누가 승리할 것인가?  
단, 같은 팀의 병사들이 대각선으로만 인접한 경우는 뭉쳐 있다고 보지 않는다.

```text
틀렸던 이유는 가로 크기가 N, 세로 크기가 M인걸 보지 못하고 가로 크기를 M, 세로 크기를 N으로 놓고 풀었기 때문

처음엔 visited를 두 번 초기화하여 bfs를 두 번 돌려야 하나 고민했었는데 생각해보니 방문처리를 graph에서 다른 값으로 하는게 아닌 visited를 이용하는 것이므로 한 번의 이중 for문에서 해결하였음
```

```python
import sys
from collections import deque
input = sys.stdin.readline

def bfs(x, y, team):
    global cnt
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < m and 0 <= ny < n:
                if graph[nx][ny] == team and visited[nx][ny] == False:
                    visited[nx][ny] = True
                    cnt += 1
                    q.append((nx, ny))

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]
n, m = map(int, input().split())
graph = []
cnt_w = 0
cnt_b = 0

# 그래프 구현
for _ in range(m):
    graph.append(list(input().rstrip()))

visited = [[False] * n for _ in range(m)]

# 그래프 탐색
for i in range(m):
    for j in range(n):
        cnt = 1
        # 흰색 팀일 경우
        if graph[i][j] == 'W' and visited[i][j] == False:
            bfs(i, j, 'W')
            if cnt > 1:
                cnt_w += cnt ** 2
            else:
                cnt_w += cnt
        # 파란 팀일 경우
        elif graph[i][j] == 'B' and visited[i][j] == False:
            bfs(i, j, 'B')
            if cnt > 1:
                cnt_b += cnt ** 2
            else:
                cnt_b += cnt

print(cnt_w, cnt_b)
```

---

### [11123번 양 한마리... 양 두마리...](https://www.acmicpc.net/problem/11123)

양을 # 으로 나타내고 . 으로 풀을 표현하는 거야. 서로 다른 # 두 개 이상이 붙어있다면 한 무리의 양들이 있는거지.  
그래... 좋았어..! 이걸로 초원에서 풀을 뜯고 있는 양들을 그리드로 표현해 보는거야!

각 테스트 케이스마다, 양의 몇 개의 무리로 이루어져 있었는지를 한 줄에 출력하면 된다.

```text
다른 문제와 같은 구역 세는 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

case = int(input())

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < h and 0 <= ny < w:
                if graph[nx][ny] == '#' and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny))




for _ in range(case):
    h, w = map(int, input().split())
    graph = []
    visited = [[False] * w for __ in range(h)]
    cnt = 0

    for __ in range(h):
        graph.append(list(input().rstrip()))

    for i in range(h):
        for j in range(w):
            if graph[i][j] == '#' and not visited[i][j]:
                cnt += 1
                bfs(i, j)

    print(cnt)
```

---

### [1937번 욕심쟁이 판다](https://www.acmicpc.net/problem/1937)

n × n의 크기의 대나무 숲이 있다.  
욕심쟁이 판다는 어떤 지역에서 대나무를 먹기 시작한다.  
그리고 그 곳의 대나무를 다 먹어 치우면 상, 하, 좌, 우 중 한 곳으로 이동을 한다.  
그리고 또 그곳에서 대나무를 먹는다. 그런데 단 조건이 있다.  
이 판다는 매우 욕심이 많아서 대나무를 먹고 자리를 옮기면 그 옮긴 지역에 그 전 지역보다 대나무가 많이 있어야 한다.

이 판다의 사육사는 이런 판다를 대나무 숲에 풀어 놓아야 하는데,  
어떤 지점에 처음에 풀어 놓아야 하고, 어떤 곳으로 이동을 시켜야 판다가 최대한 많은 칸을 방문할 수 있는지 고민에 빠져 있다.  
우리의 임무는 이 사육사를 도와주는 것이다.

n × n 크기의 대나무 숲이 주어져 있을 때,  
이 판다가 최대한 많은 칸을 이동하려면 어떤 경로를 통하여 움직여야 하는지 구하여라.

```text
DFS + DP 문제
처음엔 DFS로 구현하다가 BFS로 하면 쉬울 것 같아 BFS로 구현을 했는데 풀리지 않았다

각 점마다 모두 탐색을 진행하는 줄 알았는데 그렇게 하면 시간초과가 나고 어떠한 좌표로 이동한 최장 경로의 길이는 다시 계산할 필요가 없으므로 DP가 사용된다

BFS는 최단 거리를 구하는 알고리즘이기 때문에 DFS를 써야 한다

그러므로 이 문제는 DFS와 DP를 이용해서 푸는 문제이다

DP를 그래프에서도 활용할 수 있다는 걸 깨달았다
```

```python
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def dfs(x, y):
    if dp[x][y]:
        return dp[x][y]

    dp[x][y] = 1

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n:
            if graph[x][y] < graph[nx][ny]:
                dp[x][y] = max(dp[x][y], dfs(nx, ny) + 1)
    return dp[x][y]

n = int(input())

graph = [list(map(int, input().split())) for _ in range(n)]
dp = [[0] * n for _ in range(n)]
result = 0

for i in range(n):
    for j in range(n):
        result = max(result, dfs(i, j))

print(result)
```

---

### [3184번 양](https://www.acmicpc.net/problem/3184)

미키의 뒷마당에는 특정 수의 양이 있다.  
그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.

마당은 행과 열로 이루어진 직사각형 모양이다.  
글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다.

한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다.  
마당에서 "탈출"할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.

다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다.  
그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.

맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.

아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.

```text
구역 세기 문제와 비슷한 문제
양과 늑대의 수를 미리 세고 구역마다 진 동물의 수를 빼준다
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    global sheep
    global wolf
    q = deque()
    q.append((x, y))
    t_w = 0
    t_s = 0
    visited[x][y] = True

    if graph[x][y] == 'v':
        t_w += 1
    elif graph[x][y] == 'o':
        t_s += 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and graph[nx][ny] != '#':
                visited[nx][ny] = True
                if graph[nx][ny] == 'o':
                    t_s += 1
                if graph[nx][ny] == 'v':
                    t_w += 1
                q.append((nx, ny))
    if t_w > 0 and t_s > 0:
        if t_w >= t_s:
            sheep -= t_s
        else:
            wolf -= t_w

    if wolf >= sheep:
        return (wolf, 0)
    else:
        return (0, sheep)

r, c = map(int, input().split())
graph = []
sheep = 0
wolf = 0

# 그래프 구현
for _ in range(r):
    tmp = list(input().rstrip())
    graph.append(tmp)

    for i in range(c):
        if tmp[i] == 'o':
            sheep += 1
        elif tmp[i] == 'v':
            wolf += 1
visited = [[False] * c for _ in range(r)]

for i in range(r):
    for j in range(c):
        if graph[i][j] in ('o', 'v') and not visited[i][j]:
            bfs(i, j)

print(sheep, wolf)
```

---

### [10026번 적록색약](https://www.acmicpc.net/problem/10026)

적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다.  
따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.

크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다.  
그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다.  
또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다.  
(색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)

그림이 입력으로 주어졌을 때,  
적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.

```text
일반인과 적록색약의 bfs를 각각 구현하여 bfs를 두 개 만드려다가 적록색약이 보는 그래프를 따로 만들어서 bfs를 하나만 구현하였다
```

```python
# BFS
import sys
from collections import deque
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y, mark, visited, graph):
    visited[x][y] = True
    q = deque()
    q.append((x, y))

    while q:
        x, y = q.popleft()
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < n:
                if not visited[nx][ny] and graph[nx][ny] == mark:
                    visited[nx][ny] = True
                    q.append((nx, ny))

n = int(input())
graph1 = [list(input().rstrip()) for _ in range(n)]
graph2 = []

# 색약인 사람의 그래프 구현
for i in range(n):
    graph2.append([])
    for j in range(n):
        if graph1[i][j] == 'R' or graph1[i][j] == 'G':
            graph2[i].append('R')
        else:
            graph2[i].append('B')
visited1 = [[False] * n for _ in range(n)]
visited2 = [[False] * n for _ in range(n)]
result1 = result2 = 0

# 그래프 탐색
for i in range(n):
    for j in range(n):
        if not visited1[i][j]:
            bfs(i, j, graph1[i][j], visited1, graph1)
            result1 += 1
        if not visited2[i][j]:
            bfs(i, j, graph2[i][j], visited2, graph2)
            result2 += 1

print(result1, result2)
```

```python
# DFS
import sys
sys.setrecursionlimit(10 ** 6)
input = sys.stdin.readline

def dfs(x, y, mark, visited, graph):
    if x < 0 or x >= n or y < 0 or y >= n:
        return False

    if visited[x][y]:
        return False

    if graph[x][y] == mark:
        visited[x][y] = True
        dfs(x - 1, y, mark, visited, graph)
        dfs(x + 1, y, mark, visited, graph)
        dfs(x, y - 1, mark, visited, graph)
        dfs(x, y + 1, mark, visited, graph)
        return True
    return False

n = int(input())
graph1 = [list(input().rstrip()) for _ in range(n)]
graph2 = []

# 색약인 사람의 그래프 구현
for i in range(n):
    graph2.append([])
    for j in range(n):
        if graph1[i][j] == 'R' or graph1[i][j] == 'G':
            graph2[i].append('R')
        else:
            graph2[i].append('B')
visited1 = [[False] * n for _ in range(n)]
visited2 = [[False] * n for _ in range(n)]
result1 = result2 = 0

# 그래프 탐색
for i in range(n):
    for j in range(n):
        if dfs(i, j, graph1[i][j], visited1, graph1):
            result1 += 1
        if dfs(i, j, graph2[i][j], visited2, graph2):
            result2 += 1

print(result1, result2)
```

---

### [2589번 보물섬](https://www.acmicpc.net/problem/2589)

보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다.  
보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다.  
각 칸은 육지(L)나 바다(W)로 표시되어 있다.  
이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다.  
보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다.  
육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.

```text
시간 초과가 나와서 질문글이나 다른 코드를 참고했는데 코드가 비슷해서 해결방법을 찾아보던 중 PyPy3로 제출하라는 의견이 있어 PyPy3로 제출하고 통과되었다

브루트포스라서 모든 L에서의 경우를 탐색하다보니 시간 초과가 나오는 것 같다
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y, 0))
    visited[x][y] = True

    while q:
        x, y, time = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < m:
                if graph[nx][ny] == 'L' and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny, time + 1))
    return time


n, m = map(int, input().split())
graph = [list(input().rstrip()) for _ in range(n)]

result = 0
for i in range(n):
    for j in range(m):
        visited = [[False] * m for _ in range(n)]
        if graph[i][j] == 'L':
            result = max(result, bfs(i, j))
print(result)
```

---

### [2573번 빙산](https://www.acmicpc.net/problem/2573)

지구 온난화로 인하여 북극의 빙산이 녹고 있다.  
빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자.  
빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다.  
빙산 이외의 바다에 해당되는 칸에는 0이 저장된다.

빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에,  
배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다.  
단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다.  
바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다.

한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오.  
만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.

```text
시간 초과로 인해 PyPy3로 제출함
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < n and 0 <= ny < m:
                if graph[nx][ny] > 0 and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny))
                elif graph[nx][ny] == 0:
                    melt[x][y] += 1
    return 1

n, m = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(n)]
time = 0
result = False

while True:
    visited = [[False] * m for _ in range(n)]
    melt = [[0] * m for _ in range(n)]
    land = 0

    # 그래프 탐색
    for i in range(n):
        for j in range(m):
            if graph[i][j] > 0 and not visited[i][j]:
                land += bfs(i, j)

    # 빙산이 녹는걸 먼저 반영하면 주변에 영향이 생기므로 한번에 녹인다
    for i in range(n):
        for j in range(m):
            graph[i][j] = max(graph[i][j] - melt[i][j], 0)

    if land == 0:
        break
    elif land > 1:
        result = True
        break
    time += 1

if result:
    print(time)
else:
    print(0)
```

---

### [16948번 데스 나이트](https://www.acmicpc.net/problem/16948)

게임을 좋아하는 큐브러버는 체스에서 사용할 새로운 말 "데스 나이트"를 만들었다.  
데스 나이트가 있는 곳이 (r, c)라면, (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)로 이동할 수 있다.

크기가 N×N인 체스판과 두 칸 (r1, c1), (r2, c2)가 주어진다.  
데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 구해보자.  
체스판의 행과 열은 0번부터 시작한다.

데스 나이트는 체스판 밖으로 벗어날 수 없다.

```text
간단한 BFS 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [-2, -2, 0, 0, 2, 2]
dy = [-1, 1, -2, 2, -1, 1]

n = int(input())
r1, c1, r2, c2 = map(int, input().split())

visited = [[False] * n for _ in range(n)]

q = deque()
q.append((r1, c1, 0))
result = 0

while q:
    x, y, cnt = q.popleft()

    if x == r2 and y == c2:
        result = cnt
        break

    for i in range(6):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:
            visited[nx][ny] = True
            q.append((nx, ny, cnt + 1))

if result == 0:
    print(-1)
else:
    print(cnt)
```

---

### [17086번 아기 상어 2](https://www.acmicpc.net/problem/17086)

N×M 크기의 공간에 아기 상어 여러 마리가 있다.  
공간은 1×1 크기의 정사각형 칸으로 나누어져 있다.  
한 칸에는 아기 상어가 최대 1마리 존재한다.

어떤 칸의 안전 거리는 그 칸과 가장 거리가 가까운 아기 상어와의 거리이다.  
두 칸의 거리는 하나의 칸에서 다른 칸으로 가기 위해서 지나야 하는 칸의 수이고, 이동은 인접한 8방향(대각선 포함)이 가능하다.

안전 거리가 가장 큰 칸을 구해보자.

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [0, 0, 1, -1, 1, 1, -1, -1]
dy = [1, -1, 0, 0, 1, -1, 1, -1]

n, m = map(int, input().split())
graph = []
result = 0

# 그래프 구현
q = deque()
for i in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)
    for j in range(m):
        if tmp[j] == 1:
            q.append((i, j))

# 그래프 탐색
while q:
    x, y = q.popleft()

    for i in range(8):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m and graph[nx][ny] == 0:
            graph[nx][ny] = graph[x][y] + 1
            result = max(result, graph[nx][ny])
            q.append((nx, ny))

if result == 0:
    print(0)
# 숫자가 1부터 시작이므로 1을 빼야함
else:
    print(result - 1)

```

---

### [16173번 점프왕 쩰리 (Small)](https://www.acmicpc.net/problem/16173)

### [16174번 점프왕 쩰리 (Large)](https://www.acmicpc.net/problem/16174)

‘쩰리’는 점프하는 것을 좋아하는 젤리다.  
단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다.  
새로운 점프 게임의 조건은 다음과 같다.

1. ‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.
2. ‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.
3. ‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.
4. ‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.
5. ‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.

새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다.  
하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다.  
‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다.  
‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!

```text
16173과 16174는 N의 범위만 다르지 사실상 같은 문제
```

```python
# DFS
import sys
input = sys.stdin.readline
from collections import deque

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]
visited = [[False] * n for _ in range(n)]
success = False

def dfs(x, y):
    global success

    if x < 0 or x >= n or y < 0 or y >= n:
        return False
    if visited[x][y]:
        return False

    if graph[x][y] == -1:
        success = True
        return True

    visited[x][y] = True
    dfs(x + 1 * graph[x][y], y)
    dfs(x, y + 1 * graph[x][y])
    return True

dfs(0, 0)
if success:
    print('HaruHaru')
else:
    print('Hing')
```

```python
# BFS
import sys
input = sys.stdin.readline
from collections import deque

# 오른쪽과 아래만 이동 가능
dx = [0, 1]
dy = [1, 0]

n = int(input())
graph = [list(map(int, input().split())) for _ in range(n)]
visited = [[False] * n for _ in range(n)]
result = 0

def bfs(x, y):
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        if graph[x][y] == -1:
            return 'HaruHaru'

        for i in range(2):
            nx = x + dx[i] * graph[x][y]
            ny = y + dy[i] * graph[x][y]

            if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny]:
                visited[nx][ny] = True
                q.append((nx, ny))
    return 'Hing'

print(bfs(0, 0))
```

---

### [14940번 쉬운 최단거리](https://www.acmicpc.net/problem/14940)

지도가 주어지면 모든 지점에 대해서 목표지점까지의 거리를 구하여라.  
문제를 쉽게 만들기 위해 오직 가로와 세로로만 움직일 수 있다고 하자.

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

n, m = map(int, input().split())
mx, mx = 0, 0

# 그래프 구현
graph = []
visited = [[False] * m for _ in range(n)]
result = [[0] * m for _ in range(n)]
for i in range(n):
    tmp = list(map(int, input().split()))
    graph.append(tmp)
    for j in range(m):
        if tmp[j] == 2:
            mx, my = i, j

q = deque()
q.append((mx, my))
visited[mx][my] = True
result[mx][my] = 0

# 그래프 탐색
while q:
    x, y = q.popleft()

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] == 1 and not visited[nx][ny]:
                result[nx][ny] = result[x][y] + 1
                visited[nx][ny] = True
                q.append((nx, ny))

for i in range(n):
    for j in range(m):
        # 원래 갈 수 있는 땅인데 방문하지 못한 경우
        if not visited[i][j] and graph[i][j] == 1:
            result[i][j] = -1

# 그래프 출력
for i in range(n):
    for j in range(m):
        print(result[i][j], end=' ')
    print()
```

---

### [16397번 탈출](https://www.acmicpc.net/problem/16397)

버튼을 이리저리 눌러보던 똑똑한 홍익이는 어떻게 해야 방을 탈출할 수 있을지 금방 눈치챘다.

버튼과 수에 대해 홍익이가 알아낸 것은 다음과 같다.

1. 버튼 A를 누르면 N이 1 증가한다.
2. 버튼 B를 누르면 N에 2가 곱해진 뒤, 0이 아닌 가장 높은 자릿수의 숫자가 1 줄어든다. 예를 들어 123→146으로, 5→0으로, 3→5로 변한다. 단, N이 0이면 버튼 B를 눌러도 수가 변하지 않는다.
3. LED가 다섯 자리까지밖에 없기 때문에 N이 99,999를 넘어가는 순간 탈출에 실패하게 된다.
4. 버튼 B를 눌러 N에 2를 곱한 순간 수가 99,999를 넘어간다면, 높은 자릿수의 수를 1 낮췄을때 99,999를 넘지 않는다고 해도 탈출에 실패하게 된다.

또한 홍익이는 최대 T회 버튼을 누를 수 있고, 그 횟수 안에 LED로 표현된 N을 G와 같게 만들어야 탈출할 수 있다는 사실을 알아냈다.  
똑똑한 홍익이는 이와중에 자존심이 발동해 버튼 누르는 횟수를 최소로 하여 방을 탈출하기로 했다.

홍익이의 방 탈출을 기원하며, 탈출에 필요한 최소의 버튼 횟수를 구하자.

```text
2번 규칙을 잘못 처리해서 인덱스 에러가 났었다
처음엔
if n * 2 <= 99999:
    tmp = n * 2
    if tmp > 10000:
        tmp -= 10000
    elif tmp > 1000:
        tmp -= 1000
    elif tmp > 100:
        tmp -= 100
    elif tmp > 10:
        tmp -= 10
    else:
        tmp -= 1
이렇게 적었었는 데 n이 0일 경우를 생각하지 못했었다
쉽게 처리할 수 있는 코드를 알아와서 통과했다
```

```python
import sys
input = sys.stdin.readline
from collections import deque

n, t, g = map(int, input().split())
visited = [False] * 100000
INF = 100000
def bfs(n):
    q = deque()
    q.append((n, 0))
    visited[n] = True

    while q:
        n, cnt = q.popleft()

        if cnt > t:
            return 'ANG'
        if n == g:
            return cnt

        if n + 1 < INF and not visited[n + 1]:
            visited[n + 1] = True
            q.append((n + 1, cnt + 1))

        if n * 2 < INF:
            tmp = str(n * 2)
            if int(tmp) != 0:
                tmp = str(int(tmp[0]) - 1) + tmp[1:]
            if not visited[int(tmp)]:
                visited[int(tmp)] = True
                q.append((int(tmp), cnt + 1))
    return 'ANG'

print(bfs(n))
```

---

### [17265번 나의 인생에는 수학과 함께](https://www.acmicpc.net/problem/17265)

세현이네 집에서 학교까지 가는 길은 N x N 크기의 바둑판과 같다.  
그리고 각 블록은 1x1 정사각형으로 구분 지을 수 있다.  
세현이는 그 블록마다 숫자와 연산자가 존재한다고 생각해서 임의의 숫자와 연산자를 각 블록에 넣어 바둑판을 만들었다.

세현이는 학교에서 집으로 가는 경로에서 만나는 숫자와 연산자의 연산 결과의 최댓값과 최솟값을 구하려고 한다.  
세현이는 항상 자신의 집 (1, 1)에서 학교 (N, N)까지 최단거리로 이동한다.  
최단거리로 이동하기 위해서는 오른쪽과 아래쪽으로만 이동해야 한다.

세현이는 이 길을 걸으면서 최댓값과 최솟값을 암산하다가 교통사고를 당해 현재 인하대학교 병원에 입원했다.  
아픈 세현이를 위해 최댓값과 최솟값을 구해주자.

```python
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 6)

dx = [1, 0]
dy = [0, 1]

n = int(input())
graph = [list(input().split()) for _ in range(n)]
max_result = -int(1e9)
min_result = int(1e9)

def dfs(x, y, pre_num, op):
    global max_result, min_result

    if x == n - 1 and y == n - 1:
        max_result = max(max_result, pre_num)
        min_result = min(min_result, pre_num)

    for i in range(2):
        nx = x + dx[i]
        ny = y + dy[i]

        if nx < 0 or nx >= n or ny < 0 or ny >= n:
            continue

        # 이동한 칸이 숫자일 경우
        if graph[nx][ny].isdigit():
            if op == '+':
                dfs(nx, ny, pre_num + int(graph[nx][ny]), '')
            elif op == '-':
                dfs(nx, ny, pre_num - int(graph[nx][ny]), '')
            elif op == '*':
                dfs(nx, ny, pre_num * int(graph[nx][ny]), '')
        # 이동한 칸이 연산자일 경우
        else:
            dfs(nx, ny, pre_num, graph[nx][ny])

dfs(0, 0, int(graph[0][0]), '')
print(max_result, min_result)
```

---

### [14716번 현수막](https://www.acmicpc.net/problem/14716)

저번 학기 영상처리 수업을 듣고 배웠던 지식을 최대한 응용 해보고 싶은 혁진이는 이 현수막에서 글자가 몇 개인지 알아보는 프로그램을 만들려 한다.  
혁진이는 우선 현수막에서 글자인 부분은 1, 글자가 아닌 부분은 0으로 바꾸는 필터를 적용하여 값을 만드는데 성공했다.  
그런데 혁진이는 이 값을 바탕으로 글자인 부분 1이 상, 하, 좌, 우, 대각선으로 인접하여 서로 연결되어 있다면 한 개의 글자라고 생각만 하였다.  
혁진이가 필터를 적용하여 만든 값이 입력으로 주어졌을 때, 혁진이의 생각대로 프로그램을 구현하면 글자의 개수가 몇 개인지 출력하여라.

```text
간단한 구역 세기 문제
```

```python
# BFS
import sys
input = sys.stdin.readline
from collections import deque

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, 1, -1, 1, -1]

m, n = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(m)]
visited = [[False] * n for _ in range(m)]
cnt = 0

def bfs(x, y):
    q = deque()
    q.append((x, y))
    visited[x][y] = True

    while q:
        x, y = q.popleft()

        for i in range(8):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < m and 0 <= ny < n:
                if graph[nx][ny] == 1 and not visited[nx][ny]:
                    visited[nx][ny] = True
                    q.append((nx, ny))

for i in range(m):
    for j in range(n):
        if graph[i][j] == 1 and not visited[i][j]:
            bfs(i, j)
            cnt += 1

print(cnt)
```

```python
# DFS
import sys
input = sys.stdin.readline
sys.setrecursionlimit(10 ** 6)

dx = [1, -1, 0, 0, 1, 1, -1, -1]
dy = [0, 0, 1, -1, 1, -1, 1, -1]

m, n = map(int, input().split())
graph = [list(map(int, input().split())) for _ in range(m)]
visited = [[False] * n for _ in range(m)]
cnt = 0

def dfs(x, y):
    if x < 0 or x >= m or y < 0 or y >= n:
        return False
    if visited[x][y] or graph[x][y] == 0:
        return False
    visited[x][y] = True

    for i in range(8):
        nx = x + dx[i]
        ny = y + dy[i]
        dfs(nx, ny)
    return True

for i in range(m):
    for j in range(n):
        if dfs(i, j):
            cnt += 1

print(cnt)
```

---

### [13565번 침투](https://www.acmicpc.net/problem/13565)

인제대학교 생화학연구실에 재직중인 석교수는 전류가 침투(percolate) 할 수 있는 섬유 물질을 개발하고 있다.  
이 섬유 물질은 2차원 M × N 격자로 표현될 수 있다.  
편의상 2차원 격자의 위쪽을 바깥쪽(outer side), 아래쪽을 안쪽(inner side)라고 생각하기로 한다.  
또한 각 격자는 검은색 아니면 흰색인데, 검은색은 전류를 차단하는 물질임을 뜻하고 흰색은 전류가 통할 수 있는 물질임을 뜻한다.  
전류는 섬유 물질의 가장 바깥쪽 흰색 격자들에 공급되고, 이후에는 상하좌우로 인접한 흰색 격자들로 전달될 수 있다.

김 교수가 개발한 섬유 물질을 나타내는 정보가 2차원 격자 형태로 주어질 때,  
바깥쪽에서 흘려 준 전류가 안쪽까지 침투될 수 있는지 아닌지를 판단하는 프로그램을 작성하시오.

```text
DFS로도 풀 수 있겠지만 최단거리만 나오면 될거 같아서 BFS로 풀었다
```

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

m, n = map(int, input().split())
q = deque()
graph = []
success = False
visited = [[False] * n for _ in range(m)]
# 그래프 구현
for i in range(m):
    tmp = list(input())
    graph.append(tmp)
    for j in range(n):
        if i != 0:
            break
        # 격자의 맨 윗줄이 전류가 시작되는 부분
        if tmp[j] == '0':
            q.append((i, j))
            visited[i][j] = True

# 그래프 탐색
while q:
    x, y = q.popleft()

    # 마지막 줄까지 전류가 흘렀다면 성공
    if x == m - 1:
        success = True
        break

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < m and 0 <= ny < n:
            if graph[nx][ny] == '0' and not visited[nx][ny]:
                visited[nx][ny] = True
                q.append((nx, ny))

print('YES' if success else 'NO')
```

---

### [17129번 윌리암슨수액빨이딱따구리가 정보섬에 올라온 이유](https://www.acmicpc.net/problem/17129)

어떤 Ai,j가 0이면 빈 복도여서 지나갈 수 있고, 1이면 장애물로 막혀 지나갈 수 없다.  
윌리암슨수액빨이딱따구리 식구는 2, 청국장은 3, 스시는 4, 맥앤치즈는 5이다.  
윌리암슨수액빨이딱따구리는 단위 시간마다 한 칸, 상하좌우로 움직일 수 있다.  
2, 3, 4, 5는 장애물이 아니므로 지나갈 수 있다.  
격자 밖으로는 나갈 수 없으며 시작점으로부터 시작점까지의 거리는 0이다.  
시작점은 윌리암슨수액빨리딱따구리의 위치, 즉 2의 위치이다.

과연 윌리암슨수액빨이딱따구리 식구는 어떤 음식에 더 빨리 도착할 수 있을까?

```text
단순한 아무 음식까지의 최단거리 구하기 문제
그래프의 크기가 커서 그런지 시간초과로 인해 PyPy3로 제출함
```

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

n, m = map(int, input().split())
sx, sy = 0, 0
# 그래프 구현
graph = []
visited = [[False] * m for _ in range(n)]
for i in range(n):
    tmp = list(map(int, input().rstrip()))
    graph.append(tmp)
    for j in range(m):
        if tmp[j] == 2:
            sx, sy = i, j

q = deque()
q.append((sx, sy, 0))
visited[sx][sy] = True
result = 0

# 그래프 탐색
while q:
    x, y, cnt = q.popleft()

    if graph[x][y] >= 3:
        result = cnt
        break

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] != 1 and not visited[nx][ny]:
                visited[nx][ny] = True
                q.append((nx, ny, cnt + 1))

if result == 0:
    print('NIE')
else:
    print('TAK')
    print(result)
```

---

### [21736번 헌내기는 친구가 필요해](https://www.acmicpc.net/problem/21736)

도연이가 다니는 대학의 캠퍼스는 N x M 크기이며 캠퍼스에서 이동하는 방법은 벽이 아닌 상하좌우로 이동하는 것이다.

불쌍한 도연이를 위하여 캠퍼스에서 도연이가 만날 수 있는 사람의 수를 출력하는 프로그램을 작성해보자.

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [1, 0, -1, 0]
dy = [0, 1, 0, -1]

n, m = map(int, input().split())
# 그래프 구현
graph = []
visited = [[False] * m for _ in range(n)]
sx, sy = 0, 0
for i in range(n):
    tmp = list(input().rstrip())
    graph.append(tmp)
    for j in range(m):
        if tmp[j] == 'I':
            sx, sy = i, j
            visited[sx][sy] = True

q = deque()
q.append((sx, sy))
cnt = 0

# 그래프 탐색
while q:
    x, y = q.popleft()

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < m:
            if graph[nx][ny] != 'X' and not visited[nx][ny]:
                visited[nx][ny] = True
                # 사람인 경우에만 증가
                if graph[nx][ny] == 'P':
                    cnt += 1
                q.append((nx, ny))

print(cnt if cnt else 'TT')
```

---

### [3187번 양치기 꿍](https://www.acmicpc.net/problem/3187)

양치기 꿍은 맨날 늑대가 나타났다고 마을 사람들을 속였지만 이젠 더이상 마을 사람들이 속지 않는다.  
화가 난 꿍은 복수심에 불타 아예 늑대들을 양들이 있는 울타리안에 마구 집어넣어 양들을 잡아먹게 했다.

하지만 양들은 보통 양들이 아니다.  
같은 울타리 영역 안의 양들의 숫자가 늑대의 숫자보다 더 많을 경우 늑대가 전부 잡아먹힌다.  
물론 그 외의 경우는 양이 전부 잡아먹히겠지만 말이다.

꿍은 워낙 똑똑했기 때문에 이들의 결과는 이미 알고있다.  
만약 빈 공간을 '.'(점)으로 나타내고 울타리를 '#', 늑대를 'v', 양을 'k'라고 나타낸다면 여러분은 몇 마리의 양과 늑대가 살아남을지 계산할 수 있겠는가?

단, 울타리로 막히지 않은 영역에는 양과 늑대가 없으며 양과 늑대는 대각선으로 이동할 수 없다.

```text
3184번과 양의 기호만 다르지 같은 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

def bfs(x, y):
    global sheep
    global wolf
    q = deque()
    q.append((x, y))
    t_w = 0
    t_s = 0
    visited[x][y] = True

    if graph[x][y] == 'v':
        t_w += 1
    elif graph[x][y] == 'k':
        t_s += 1

    while q:
        x, y = q.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c and not visited[nx][ny] and graph[nx][ny] != '#':
                visited[nx][ny] = True
                if graph[nx][ny] == 'k':
                    t_s += 1
                if graph[nx][ny] == 'v':
                    t_w += 1
                q.append((nx, ny))
    if t_w > 0 and t_s > 0:
        if t_w >= t_s:
            sheep -= t_s
        else:
            wolf -= t_w

    if wolf >= sheep:
        return (wolf, 0)
    else:
        return (0, sheep)

r, c = map(int, input().split())
graph = []
sheep = 0
wolf = 0

# 그래프 구현
for _ in range(r):
    tmp = list(input().rstrip())
    graph.append(tmp)

    for i in range(c):
        if tmp[i] == 'k':
            sheep += 1
        elif tmp[i] == 'v':
            wolf += 1
visited = [[False] * c for _ in range(r)]

for i in range(r):
    for j in range(c):
        if graph[i][j] in ('k', 'v') and not visited[i][j]:
            bfs(i, j)

print(sheep, wolf)
```

---

### [4179 불!](https://www.acmicpc.net/problem/4179)

지훈이는 미로에서 일을 한다. 지훈이를 미로에서 탈출하도록 도와주자!  
미로에서의 지훈이의 위치와 불이 붙은 위치를 감안해서 지훈이가 불에 타기전에 탈출할 수 있는지의 여부, 그리고 얼마나 빨리 탈출할 수 있는지를 결정해야한다.  
지훈이와 불은 매 분마다 한칸씩 수평또는 수직으로(비스듬하게 이동하지 않는다) 이동한다.  
불은 각 지점에서 네 방향으로 확산된다.  
지훈이는 미로의 가장자리에 접한 공간에서 탈출할 수 있다.  
지훈이와 불은 벽이 있는 공간은 통과하지 못한다.

입력의 첫째 줄에는 공백으로 구분된 두 정수 R과 C가 주어진다.  
단, 1 ≤ R, C ≤ 1000 이다. R은 미로 행의 개수, C는 열의 개수이다.  
다음 입력으로 R줄동안 각각의 미로 행이 주어진다. 각각의 문자들은 다음을 뜻한다.

1. #: 벽
2. .: 지나갈 수 있는 공간
3. J: 지훈이의 미로에서의 초기위치 (지나갈 수 있는 공간)
4. F: 불이 난 공간

J는 입력에서 하나만 주어진다.

지훈이가 불이 도달하기 전에 미로를 탈출 할 수 없는 경우 IMPOSSIBLE 을 출력한다.  
지훈이가 미로를 탈출할 수 있는 경우에는 가장 빠른 탈출시간을 출력한다.

```text
Python 제출: 시간 초과
PyPy3 제출:  메모리 초과

시간 초과가 난 이유는 지훈이의 탈출 조건을 잘못 입력했던 것이고
메모리 초과가 난 이유는 지훈이의 방문처리를 제대로 해주지 않아서 발생했다
추가로 지훈이가 갈 수 있는 곳 중 불이 번지지 않은 곳은 갈 수 없도록 코드가 짜여진 문제도 있었다

```

```python
# 오답인 코드
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

r, c = map(int, input().split())
q = deque()
jx, jy = 0, 0
result = 0

# 그래프 구현
graph = []
fire_graph = [[0] * c for _ in range(r)]
for i in range(r):
    tmp = list(input())
    graph.append(tmp)
    for j in range(c):
        if tmp[j] == 'F':
            q.append((i, j))
            fire_graph[i][j] = 1
        if tmp[j] == 'J':
            jx, jy = i, j


# 불의 그래프 탐색
while q:
    x, y = q.popleft()

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < r and 0 <= ny < c:
            if fire_graph[nx][ny] == 0 and graph[nx][ny] != '#':
                fire_graph[nx][ny] = fire_graph[x][y] + 1
                q.append((nx, ny))

q = deque()
q.append((jx, jy))
visited = [[0] * c for _ in range(r)]
visited[jx][jy] = 1
# 지훈이의 그래프 탐색
while q:
    x, y = q.popleft()

    # 지훈이의 탈출조건이 잘못 명시됨
    # x >= r or x < 0 or y >= c or y < 0이라고 적었어야 한다
    if x == r - 1 or x == 0 or y == c - 1 or y == 0:
        result = visited[x][y]
        break

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < r and 0 <= ny < c:
            # 지훈이가 갈 수 있는 곳 중 불이 번지지 않은 곳을 적지 않음
            # fire_graph[nx][ny] > visited[x][y] + 1 부분에
            # or fire_graph[nx][ny] == 0을 적어 줬어야 함
            if graph[nx][ny] != '#' and fire_graph[nx][ny] > visited[x][y] + 1:
                # 지훈이의 방문처리를 제대로 해주지 않음
                # graph[nx][ny] != '#' 이 부분에 and not visited_j[nx][ny]
                # 이 코드가 추가되었어야 함
                visited[nx][ny] = visited[x][y] + 1
                q.append((nx, ny))

if result:
    print(result)
else:
    print('IMPOSSIBLE')
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [1, -1, 0, 0]
dy = [0, 0, 1, -1]

r, c = map(int, input().split())
graph = []

q_j = deque()
q_f = deque()

visited_j = [[0] * c for _ in range(r)]
visited_f = [[0] * c for _ in range(r)]

# 그래프 구현
for i in range(r):
    tmp = list(input())
    graph.append(tmp)

    for j in range(c):
        if tmp[j] == 'J':
            q_j.append((i, j))
            visited_j[i][j] = 1

        elif tmp[j] == 'F':
            q_f.append((i, j))
            visited_f[i][j] = 1
def bfs():
    # 불의 그래프 탐색
    while q_f:
        x, y = q_f.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c:
                if not visited_f[nx][ny] and graph[nx][ny] != '#':
                    visited_f[nx][ny] = visited_f[x][y] + 1
                    q_f.append((nx, ny))

    # 지훈이의 그래프 탐색
    while q_j:
        x, y = q_j.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c:
                if graph[nx][ny] != '#' and not visited_j[nx][ny]:
                    if not visited_f[nx][ny] or visited_f[nx][ny] > visited_j[x][y] + 1:
                        visited_j[nx][ny] = visited_j[x][y] + 1
                        q_j.append((nx, ny))
            else:
                return visited_j[x][y]
    return 'IMPOSSIBLE'

print(bfs())
```

---

### [3055번 탈출](https://www.acmicpc.net/problem/3055)

티떱숲의 지도는 R행 C열로 이루어져 있다.  
비어있는 곳은 '.'로 표시되어 있고, 물이 차있는 지역은 '\*', 돌은 'X'로 표시되어 있다.  
비버의 굴은 'D'로, 고슴도치의 위치는 'S'로 나타내어져 있다.

매 분마다 고슴도치는 현재 있는 칸과 인접한 네 칸 중 하나로 이동할 수 있다. (위, 아래, 오른쪽, 왼쪽)  
물도 매 분마다 비어있는 칸으로 확장한다.  
물이 있는 칸과 인접해있는 비어있는 칸(적어도 한 변을 공유)은 물이 차게 된다.  
물과 고슴도치는 돌을 통과할 수 없다.  
또, 고슴도치는 물로 차있는 구역으로 이동할 수 없고, 물도 비버의 소굴로 이동할 수 없다.

티떱숲의 지도가 주어졌을 때,  
고슴도치가 안전하게 비버의 굴로 이동하기 위해 필요한 최소 시간을 구하는 프로그램을 작성하시오.

고슴도치는 물이 찰 예정인 칸으로 이동할 수 없다.
즉, 다음 시간에 물이 찰 예정인 칸으로 고슴도치는 이동할 수 없다. 이동할 수 있으면 고슴도치가 물에 빠지기 때문이다.

```text
4179번과 같은 문제
이지만 답을 리턴할 때 4179의 경우 실제로 이동하기 전에 범위를 검색해서 1을 더해주지 않고 그 전 값을 리턴하고 이 문제의 경우 이동한 후에 범위를 검색해서 값을 리턴하므로 1을 빼줘야 한다
```

```python
import sys
input = sys.stdin.readline
from collections import deque

dx = [0, 1, 0, -1]
dy = [1, 0, -1, 0]

r, c = map(int, input().split())
graph = []
q_w = deque()
q_g = deque()

visited_w = [[0] * c for _ in range(r)]
visited_g = [[0] * c for _ in range(r)]

goal_x, goal_y = 0, 0

# 그래프 구현
for i in range(r):
    tmp = list(input())
    graph.append(tmp)

    for j in range(c):
        if tmp[j] == '*':
            q_w.append((i, j))
            visited_w[i][j] = 1
        elif tmp[j] == 'S':
            q_g.append((i, j))
            visited_g[i][j] = 1
        elif tmp[j] == 'D':
            goal_x, goal_y = i, j

def bfs():
    # 물의 그래프 탐색
    while q_w:
        x, y = q_w.popleft()

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c:
                if graph[nx][ny] not in ('D', 'X') and not visited_w[nx][ny]:
                    visited_w[nx][ny] = visited_w[x][y] + 1
                    q_w.append((nx, ny))

    # 고슴도치의 그래프 탐색
    while q_g:
        x, y = q_g.popleft()

        # for문을 돌았기 때문에 1을 빼줘야 한다
        if x == goal_x and y == goal_y:
            return visited_g[x][y] - 1

        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]

            if 0 <= nx < r and 0 <= ny < c:
                if graph[nx][ny] != 'X' and not visited_g[nx][ny]:
                    if not visited_w[nx][ny] or visited_w[nx][ny] > visited_g[x][y] + 1:
                        visited_g[nx][ny] = visited_g[x][y] + 1
                        q_g.append((nx, ny))
    return 'KAKTUS'

print(bfs())
```

---

### [5014번 스타트링크](https://www.acmicpc.net/problem/5014)

스타트링크는 총 F층으로 이루어진 고층 건물에 사무실이 있고, 스타트링크가 있는 곳의 위치는 G층이다.  
강호가 지금 있는 곳은 S층이고, 이제 엘리베이터를 타고 G층으로 이동하려고 한다.

보통 엘리베이터에는 어떤 층으로 이동할 수 있는 버튼이 있지만, 강호가 탄 엘리베이터는 버튼이 2개밖에 없다.  
U버튼은 위로 U층을 가는 버튼, D버튼은 아래로 D층을 가는 버튼이다.  
(만약, U층 위, 또는 D층 아래에 해당하는 층이 없을 때는, 엘리베이터는 움직이지 않는다)

강호가 G층에 도착하려면, 버튼을 적어도 몇 번 눌러야 하는지 구하는 프로그램을 작성하시오.  
만약, 엘리베이터를 이용해서 G층에 갈 수 없다면, "use the stairs"를 출력한다.

```text
처음엔 현재 층이 도착 층보다 작을 때만 up을 누르고 클 때만 down을 눌렀는 데 그렇게하면 down을 눌러야만 하는 상황을 배제하기 때문에 큐에 up과 down인 상황 모두를 넣었다
```

```python
import sys
input = sys.stdin.readline
from collections import deque

f, s, g, u, d = map(int, input().split())
visited = [False for _ in range(f + 1)]
visited[s] = True

q = deque()
q.append((s, 0))

def bfs():
    while q:
        floor, cnt = q.popleft()

        if floor == g:
            return cnt

        tmp = floor + u
        if tmp <= f and not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, cnt + 1))

        tmp = floor - d
        if tmp >= 1 and not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, cnt + 1))
    return 'use the stairs'

print(bfs())
```

---

### [9019번 DSLR](https://www.acmicpc.net/problem/9019)

네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다.  
이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 0 이상 10,000 미만의 십진수를 저장할 수 있다.  
각 명령어는 이 레지스터에 저장된 n을 다음과 같이 변환한다.  
n의 네 자릿수를 d1, d2, d3, d4라고 하자  
(즉 n = ((d1 × 10 + d2) × 10 + d3) × 10 + d4라고 하자)

1. D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 그 결과 값(2n mod 10000)을 레지스터에 저장한다.
2. S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.
3. L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.
4. R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.

```text
S 연산에서 n - 1의 값이 음수가 나올 때가 있어 어떻게 처리해야하나 생각하느라 많이 틀렸다
시간 초과로 인해 PyPy3로 제출함
```

```python
import sys
input = sys.stdin.readline
from collections import deque

def bfs(a, b, visited):
    q = deque()
    q.append((a, ''))
    visited[a] = True

    while q:
        num, op = q.popleft()

        if num == b:
            return op

        # D
        tmp = (num * 2) % 10000
        if not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, op + 'D'))

        # S
        tmp = (num - 1) % 10000
        if not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, op + 'S'))
        # L
        tmp = str(num)
        if len(tmp) < 4:
            tmp = '0' * (4 - len(tmp)) + tmp
        tmp = int(tmp[1:] + tmp[0]) % 10000
        if not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, op + 'L'))

        # D
        tmp = str(num)
        if len(tmp) < 4:
            tmp = '0' * (4 - len(tmp)) + tmp
        tmp = int(tmp[-1] + tmp[0:-1]) % 10000
        if not visited[tmp]:
            visited[tmp] = True
            q.append((tmp, op + 'R'))

case = int(input())
for _ in range(case):
    a, b = map(int, input().split())
    visited = [False] * 10000
    print(bfs(a, b, visited))
```

---

### [1261번 알고스팟](https://www.acmicpc.net/problem/1261)

알고스팟 운영진이 모두 미로에 갇혔다. 미로는 NxM 크기이며, 총 1x1크기의 방으로 이루어져 있다.  
미로는 빈 방 또는 벽으로 이루어져 있고, 빈 방은 자유롭게 다닐 수 있지만, 벽은 부수지 않으면 이동할 수 없다.

알고스팟 운영진은 여러명이지만, 항상 모두 같은 방에 있어야 한다.  
즉, 여러 명이 다른 방에 있을 수는 없다.  
어떤 방에서 이동할 수 있는 방은 상하좌우로 인접한 빈 방이다.

즉, 현재 운영진이 (x, y)에 있을 때,  
이동할 수 있는 방은 (x+1, y), (x, y+1), (x-1, y), (x, y-1) 이다. 단, 미로의 밖으로 이동 할 수는 없다.

벽은 평소에는 이동할 수 없지만, 알고스팟의 무기 AOJ를 이용해 벽을 부수어 버릴 수 있다.  
벽을 부수면, 빈 방과 동일한 방으로 변한다.

만약 이 문제가 알고스팟에 있다면, 운영진들은 궁극의 무기 sudo를 이용해 벽을 한 번에 다 없애버릴 수 있지만,  
안타깝게도 이 문제는 Baekjoon Online Judge에 수록되어 있기 때문에, sudo를 사용할 수 없다.

현재 (1, 1)에 있는 알고스팟 운영진이 (N, M)으로 이동하려면 벽을 최소 몇 개 부수어야 하는지 구하는 프로그램을 작성하시오.

```text
벽이 아닐 경우는 그냥 이동하고 벽일 경우에만 값을 증가시켜 넣어서 풀면 되겠다 싶었는데 풀리지 않아서 알고리즘 분류를 확인해보니 0-1 너비 우선 탐색이라는 이상한 게 있었다

0-1 BFS란
가중치가 0과 1로만 주어진 그래프에서 최단 경로를 찾고자 할 때 쓰는 알고리즘이라고 한다
다익스트라 알고리즘의 시간복잡도가 O(ElogE) 또는 O(ElogV)인데 0-1 BFS를 사용하면 O(V+E)의 선형 시간 복잡도로 문제를 해결할 수 있다고 한다
기존 BFS와 다른 점은 가중치가 0일 때 덱의 front에, 1일 때 back에 삽입하여야 한다는 점

비용이 적은 경로부터 탐색을 진행하기 때문에 특정 간선을 2번 이상 지나가는 경우가 없으니 O(E)
모든 정점도 2번 이상 경유하는 경우가 없으므로 덱 크기는 최대 |V|이므로 O(V)
따라서 O(V) + O(E) = O(V+E)이다
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

n, m = map(int, input().split())
graph = [list(map(int, input().rstrip())) for _ in range(m)]
visited = [[False] * n for _ in range(m)]

x, y = 0, 0
q = deque()
# x, y, 뚫은 벽의 갯수
q.append((x, y, 0))
result = 0

while q:
    x, y, cnt = q.popleft()

    if x == m - 1 and y == n - 1:
        result = cnt
        break

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]:
            visited[nx][ny] = True
            if graph[nx][ny] == 1:
                q.append((nx, ny, cnt + 1))
            else:
                q.appendleft((nx, ny, cnt))

print(result)
```

---

### [13549번 숨바꼭질 3](https://www.acmicpc.net/problem/13549)

수빈이는 동생과 숨바꼭질을 하고 있다.  
수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.  
수빈이는 걷거나 순간이동을 할 수 있다.  
만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다.  
순간이동을 하는 경우에는 0초 후에 2\*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때,  
수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

```text
위의 1261번과 같은 0-1 BFS 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

n, k = map(int, input().split())
visited = [-1 for _ in range(100001)]
q = deque()
q.append(n)
visited[n] = 0

while q:
    pos = q.popleft()

    if pos == k:
        print(visited[pos])
        break

    if 0 <= pos - 1 < 100001 and visited[pos - 1] == -1:
        visited[pos - 1] = visited[pos] + 1
        q.append(pos - 1)
    if 0 < pos * 2 < 100001 and visited[pos * 2] == -1:
        visited[pos * 2] = visited[pos]
        q.appendleft(pos * 2)
    if 0 <= pos + 1 < 100001 and visited[pos + 1] == -1:
        visited[pos + 1] = visited[pos] + 1
        q.append(pos + 1)
```

---

### [2665번 미로만들기](https://www.acmicpc.net/problem/2665)

n×n 바둑판 모양으로 총 n2개의 방이 있다.  
일부분은 검은 방이고 나머지는 모두 흰 방이다.  
검은 방은 사면이 벽으로 싸여 있어 들어갈 수 없다.  
서로 붙어 있는 두 개의 흰 방 사이에는 문이 있어서 지나다닐 수 있다.  
윗줄 맨 왼쪽 방은 시작방으로서 항상 흰 방이고, 아랫줄 맨 오른쪽 방은 끝방으로서 역시 흰 방이다.

시작방에서 출발하여 길을 찾아서 끝방으로 가는 것이 목적인데, 아래 그림의 경우에는 시작방에서 끝 방으로 갈 수가 없다.  
부득이 검은 방 몇 개를 흰 방으로 바꾸어야 하는데 되도록 적은 수의 방의 색을 바꾸고 싶다.

검은 방에서 흰 방으로 바꾸어야 할 최소의 수를 구하는 프로그램을 작성하시오.  
단, 검은 방을 하나도 흰방으로 바꾸지 않아도 되는 경우는 0이 답이다.

```text
위의 두 문제와 같은 0-1 BFS 기본 문제
```

```python
import sys
from collections import deque
input = sys.stdin.readline

dx = [0, 0, 1, -1]
dy = [1, -1, 0, 0]

n = int(input())
graph = [list(map(int, input().rstrip())) for _ in range(n)]
visited = [[-1] * n for _ in range(n)]
q = deque()
q.append((0, 0))
visited[0][0] = 0
result = 0

while q:
    x, y = q.popleft()

    if x == n - 1 and y == n - 1:
        result = visited[x][y]
        break

    for i in range(4):
        nx = x + dx[i]
        ny = y + dy[i]

        if 0 <= nx < n and 0 <= ny < n and visited[nx][ny] == -1:
            if graph[nx][ny] == 0:
                visited[nx][ny] = visited[x][y] + 1
                q.append((nx, ny))
            else:
                visited[nx][ny] = visited[x][y]
                q.appendleft((nx, ny))
print(result)
```
